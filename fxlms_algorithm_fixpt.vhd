-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\Public\codegen\fxlms_algorithm\hdlsrc\fxlms_algorithm_fixpt.vhd
-- Created: 2024-07-10 13:17:21
-- 
-- Generated by MATLAB 9.14, MATLAB Coder 5.6 and HDL Coder 4.1
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: fxlms_algorithm_fixpt
-- Source Path: fxlms_algorithm_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.fxlms_algorithm_fixpt_pkg.ALL;

ENTITY fxlms_algorithm_fixpt IS
  PORT( A                                 :   IN    vector_of_std_logic_vector4(0 TO 999);  -- sfix4 [1000]
        D                                 :   IN    vector_of_std_logic_vector3(0 TO 999);  -- sfix3 [1000]
        M                                 :   IN    std_logic_vector(4 DOWNTO 0);  -- ufix5
        mu                                :   IN    std_logic;  -- ufix1
        estimated_secondary_path          :   IN    vector_of_std_logic_vector2(0 TO 4);  -- sfix2 [5]
        w                                 :   OUT   vector_of_std_logic_vector2(0 TO 23);  -- sfix2 [24]
        E                                 :   OUT   vector_of_std_logic_vector3(0 TO 999);  -- sfix3 [1000]
        Est                               :   OUT   vector_of_std_logic_vector3(0 TO 999);  -- sfix3 [1000]
        Err                               :   OUT   vector_of_std_logic_vector3(0 TO 999)  -- sfix3 [1000]
        );
END fxlms_algorithm_fixpt;


ARCHITECTURE rtl OF fxlms_algorithm_fixpt IS

  -- Signals
  SIGNAL A_signed                         : vector_of_signed4(0 TO 999);  -- sfix4 [1000]
  SIGNAL D_signed                         : vector_of_signed3(0 TO 999);  -- sfix3 [1000]
  SIGNAL M_unsigned                       : unsigned(4 DOWNTO 0);  -- ufix5
  SIGNAL estimated_secondary_path_signed  : vector_of_signed2(0 TO 4);  -- sfix2 [5]
  SIGNAL w_tmp                            : vector_of_signed2(0 TO 23);  -- sfix2 [24]
  SIGNAL E_tmp                            : vector_of_signed3(0 TO 999);  -- sfix3 [1000]
  SIGNAL Est_tmp                          : vector_of_signed3(0 TO 999);  -- sfix3 [1000]
  SIGNAL Err_tmp                          : vector_of_signed3(0 TO 999);  -- sfix3 [1000]

BEGIN
  outputgen6: FOR k1 IN 0 TO 999 GENERATE
    A_signed(k1) <= signed(A(k1));
  END GENERATE;

  outputgen5: FOR k1 IN 0 TO 999 GENERATE
    D_signed(k1) <= signed(D(k1));
  END GENERATE;

  M_unsigned <= unsigned(M);

  outputgen4: FOR k1 IN 0 TO 4 GENERATE
    estimated_secondary_path_signed(k1) <= signed(estimated_secondary_path(k1));
  END GENERATE;

  fxlms_algorithm_fixpt_1_output : PROCESS (A_signed, D_signed, M_unsigned, estimated_secondary_path_signed, mu)
    VARIABLE C : vector_of_signed9(0 TO 27);
    VARIABLE w1 : vector_of_signed2(0 TO 23);
    VARIABLE E1 : vector_of_signed3(0 TO 999);
    VARIABLE X : vector_of_signed4(0 TO 23);
    VARIABLE w_0 : vector_of_signed2(0 TO 23);
    VARIABLE Est1 : vector_of_signed3(0 TO 999);
    VARIABLE c_0 : signed(10 DOWNTO 0);
    VARIABLE tmp : signed(31 DOWNTO 0);
    VARIABLE ABZero : signed(8 DOWNTO 0);
    VARIABLE sub_temp : signed(31 DOWNTO 0);
    VARIABLE tmp_0 : signed(31 DOWNTO 0);
    VARIABLE tmp_1 : signed(31 DOWNTO 0);
    VARIABLE x_0 : vector_of_signed4(0 TO 23);
    VARIABLE tmp_2 : signed(12 DOWNTO 0);
    VARIABLE x_1 : vector_of_signed4(0 TO 23);
    VARIABLE c_1 : vector_of_signed9(0 TO 27);
    VARIABLE c_2 : signed(5 DOWNTO 0);
    VARIABLE c_3 : signed(10 DOWNTO 0);
    VARIABLE Xf : vector_of_signed4(0 TO 23);
    VARIABLE tmp_3 : signed(31 DOWNTO 0);
    VARIABLE abzero_0 : signed(8 DOWNTO 0);
    VARIABLE sub_temp_0 : signed(31 DOWNTO 0);
    VARIABLE tmp_4 : signed(31 DOWNTO 0);
    VARIABLE tmp_5 : signed(31 DOWNTO 0);
    VARIABLE x_2 : vector_of_signed4(0 TO 23);
    VARIABLE tmp_6 : signed(12 DOWNTO 0);
    VARIABLE c_4 : signed(5 DOWNTO 0);
    VARIABLE c_5 : signed(10 DOWNTO 0);
    VARIABLE xf_0 : vector_of_signed4(0 TO 23);
    VARIABLE tmp_7 : signed(31 DOWNTO 0);
    VARIABLE abzero_1 : signed(8 DOWNTO 0);
    VARIABLE sub_temp_1 : signed(31 DOWNTO 0);
    VARIABLE tmp_8 : signed(31 DOWNTO 0);
    VARIABLE tmp_9 : signed(31 DOWNTO 0);
    VARIABLE x_3 : vector_of_signed4(0 TO 23);
    VARIABLE tmp_10 : signed(12 DOWNTO 0);
    VARIABLE e_0 : vector_of_signed3(0 TO 999);
    VARIABLE x_4 : vector_of_signed4(0 TO 23);
    VARIABLE c_6 : vector_of_signed9(0 TO 27);
    VARIABLE slice_temp : signed(3 DOWNTO 0);
    VARIABLE slice_temp_0 : signed(3 DOWNTO 0);
    VARIABLE cast : vector_of_signed32(0 TO 999);
    VARIABLE cast_0 : vector_of_signed32(0 TO 999);
    VARIABLE cast_1 : vector_of_signed32(0 TO 999);
    VARIABLE sub_temp_2 : vector_of_signed12(0 TO 999);
    VARIABLE cast_2 : vector_of_unsigned2(0 TO 999);
    VARIABLE cast_3 : vector_of_signed3(0 TO 999);
    VARIABLE add_temp : vector_of_signed12(0 TO 23);
    VARIABLE sub_temp_3 : vector_of_signed12(0 TO 999);
    VARIABLE cast_4 : vector_of_unsigned2(0 TO 999);
    VARIABLE cast_5 : vector_of_signed3(0 TO 999);
    VARIABLE add_temp_0 : vector_of_signed11(0 TO 23);
    VARIABLE add_temp_1 : vector_of_signed12(0 TO 23);
    VARIABLE cast_6 : vector_of_signed4(0 TO 23);
    VARIABLE add_temp_2 : vector_of_signed12(0 TO 23);
    VARIABLE add_temp_3 : vector_of_signed11(0 TO 23);
    VARIABLE add_temp_4 : vector_of_signed10(0 TO 22);
    VARIABLE add_temp_5 : vector_of_signed10(0 TO 22);
    VARIABLE add_temp_6 : vector_of_signed10(0 TO 22);
  BEGIN
    tmp := to_signed(16#00000000#, 32);
    sub_temp := to_signed(16#00000000#, 32);
    c_2 := to_signed(16#00#, 6);
    tmp_3 := to_signed(16#00000000#, 32);
    sub_temp_0 := to_signed(16#00000000#, 32);
    c_4 := to_signed(16#00#, 6);
    tmp_7 := to_signed(16#00000000#, 32);
    sub_temp_1 := to_signed(16#00000000#, 32);
    c_0 := to_signed(16#000#, 11);
    ABZero := to_signed(16#000#, 9);
    tmp_0 := to_signed(16#00000000#, 32);
    tmp_1 := to_signed(16#00000000#, 32);
    c_3 := to_signed(16#000#, 11);
    abzero_0 := to_signed(16#000#, 9);
    tmp_4 := to_signed(16#00000000#, 32);
    tmp_5 := to_signed(16#00000000#, 32);
    c_5 := to_signed(16#000#, 11);
    abzero_1 := to_signed(16#000#, 9);
    tmp_8 := to_signed(16#00000000#, 32);
    tmp_9 := to_signed(16#00000000#, 32);
    tmp_10 := to_signed(16#0000#, 13);
    slice_temp_0 := to_signed(16#0#, 4);
    tmp_6 := to_signed(16#0000#, 13);
    slice_temp := to_signed(16#0#, 4);
    tmp_2 := to_signed(16#0000#, 13);
    --HDL code generation from MATLAB function: fxlms_algorithm_fixpt
    -- Estimation of signal
    -- Take the first M elements
    -- Filter the reference signal through the estimated secondary path
    -- Update the reference signal buffer
    -- Update filter weights
    -- Error signal
    --taking the first 24 elements
    -- Filter the reference signal through the estimated secondary path
    --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    --                                                                          %
    --          Generated by MATLAB 9.14 and Fixed-Point Designer 7.6           %
    --                                                                          %
    --%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    -- Number of samples
    w1 := (OTHERS => to_signed(16#0#, 2));
    -- Adaptive filter coefficients
    E1 := (OTHERS => to_signed(16#0#, 3));
    -- Error signal
    -- Filtered reference signal
    X := (OTHERS => to_signed(16#0#, 4));
    e_0 := E1;
    x_4 := X;
    w_0 := w1;

    FOR i_0 IN 0 TO 999 LOOP
      tmp_10 := to_signed(i_0, 32)(12 DOWNTO 0);
      cast(i_0) := signed(resize(M_unsigned, 32));
      IF to_signed(i_0, 32) >= cast(i_0) THEN 
        x_3 := x_4;
        x_3(1 TO 23) := x_4(0 TO 22);
        x_3(0) := A_signed(to_integer(resize(tmp_10, 32) - 1));

        FOR jc_1 IN 0 TO 27 LOOP
          IF (jc_1 + 1) > to_signed(16#00000018#, 32) THEN 
            tmp_9 := to_signed(16#00000016#, 32);
          ELSE 
            tmp_9 := to_signed(jc_1 - 1, 32);
          END IF;
          IF (jc_1 + 2) > to_signed(16#00000005#, 32) THEN 
            tmp_8 := to_signed(jc_1 - 4, 32);
          ELSE 
            tmp_8 := to_signed(16#00000000#, 32);
          END IF;
          sub_temp_1 := tmp_9 - tmp_8;
          abzero_1 := resize(x_3(to_integer(tmp_8)) * estimated_secondary_path_signed(to_integer(to_signed(jc_1, 32) - tmp_8)), 9);

          FOR k_1 IN 0 TO 22 LOOP
            tmp_7 := (tmp_8 + to_signed(k_1, 32)) + 1;
            IF to_signed(k_1, 32) <= sub_temp_1 THEN 
              add_temp_4(k_1) := resize(abzero_1, 10) + resize(x_3(to_integer(tmp_7)) * estimated_secondary_path_signed(to_integer(to_signed(jc_1, 32) - tmp_7)), 10);
              abzero_1 := add_temp_4(k_1)(8 DOWNTO 0);
            END IF;
          END LOOP;

          c_6(jc_1) := abzero_1;
        END LOOP;

        c_5 := to_signed(16#000#, 11);

        FOR k_2 IN 0 TO 23 LOOP
          slice_temp_0 := c_6(k_2)(3 DOWNTO 0);
          xf_0(k_2) := slice_temp_0;
          add_temp(k_2) := resize(c_5, 12) + resize(w_0(k_2) * slice_temp_0, 12);
          c_5 := add_temp(k_2)(10 DOWNTO 0);
        END LOOP;

        sub_temp_2(i_0) := resize(D_signed(to_integer(resize(tmp_10, 32) - 1)), 12) - resize(c_5, 12);
        e_0(to_integer(resize(tmp_10, 32) - 1)) := sub_temp_2(i_0)(2 DOWNTO 0);
        cast_2(i_0) := unsigned'(mu & '0');
        cast_3(i_0) := signed(resize(cast_2(i_0), 3));
        c_4 := cast_3(i_0) * e_0(to_integer(resize(tmp_10, 32) - 1));

        FOR t_1 IN 0 TO 23 LOOP
          add_temp_0(t_1) := resize(w_0(t_1), 11) + resize(c_4 * xf_0(t_1), 11);
          w_0(t_1) := add_temp_0(t_1)(1 DOWNTO 0);
          x_4(t_1) := x_3(t_1);
        END LOOP;

      END IF;
      tmp_6 := to_signed(i_0, 32)(12 DOWNTO 0);
      cast_0(i_0) := signed(resize(M_unsigned, 32));
      IF to_signed(i_0, 32) >= cast_0(i_0) THEN 
        x_2 := X;
        x_2(1 TO 23) := X(0 TO 22);
        x_2(0) := A_signed(to_integer(resize(tmp_6, 32) - 1));

        FOR jc_0 IN 0 TO 27 LOOP
          IF (jc_0 + 1) > to_signed(16#00000018#, 32) THEN 
            tmp_5 := to_signed(16#00000016#, 32);
          ELSE 
            tmp_5 := to_signed(jc_0 - 1, 32);
          END IF;
          IF (jc_0 + 2) > to_signed(16#00000005#, 32) THEN 
            tmp_4 := to_signed(jc_0 - 4, 32);
          ELSE 
            tmp_4 := to_signed(16#00000000#, 32);
          END IF;
          sub_temp_0 := tmp_5 - tmp_4;
          abzero_0 := resize(x_2(to_integer(tmp_4)) * estimated_secondary_path_signed(to_integer(to_signed(jc_0, 32) - tmp_4)), 9);

          FOR k_0 IN 0 TO 22 LOOP
            tmp_3 := (tmp_4 + to_signed(k_0, 32)) + 1;
            IF to_signed(k_0, 32) <= sub_temp_0 THEN 
              add_temp_5(k_0) := resize(abzero_0, 10) + resize(x_2(to_integer(tmp_3)) * estimated_secondary_path_signed(to_integer(to_signed(jc_0, 32) - tmp_3)), 10);
              abzero_0 := add_temp_5(k_0)(8 DOWNTO 0);
            END IF;
          END LOOP;

          C(jc_0) := abzero_0;
        END LOOP;

        c_3 := to_signed(16#000#, 11);

        FOR k_3 IN 0 TO 23 LOOP
          slice_temp := C(k_3)(3 DOWNTO 0);
          Xf(k_3) := slice_temp;
          add_temp_1(k_3) := resize(c_3, 12) + resize(w1(k_3) * slice_temp, 12);
          c_3 := add_temp_1(k_3)(10 DOWNTO 0);
        END LOOP;

        sub_temp_3(i_0) := resize(D_signed(to_integer(resize(tmp_6, 32) - 1)), 12) - resize(c_3, 12);
        E1(to_integer(resize(tmp_6, 32) - 1)) := sub_temp_3(i_0)(2 DOWNTO 0);
        cast_4(i_0) := unsigned'(mu & '0');
        cast_5(i_0) := signed(resize(cast_4(i_0), 3));
        c_2 := cast_5(i_0) * E1(to_integer(resize(tmp_6, 32) - 1));

        FOR t_2 IN 0 TO 23 LOOP
          add_temp_3(t_2) := resize(w1(t_2), 11) + resize(c_2 * Xf(t_2), 11);
          w1(t_2) := add_temp_3(t_2)(1 DOWNTO 0);
          X(t_2) := x_2(t_2);
        END LOOP;

      END IF;
    END LOOP;

    -- Estimation of signal
    x_1 := (OTHERS => to_signed(16#0#, 4));
    Est1 := (OTHERS => to_signed(16#0#, 3));

    FOR i IN 0 TO 999 LOOP
      tmp_2 := to_signed(i, 32)(12 DOWNTO 0);
      cast_1(i) := signed(resize(M_unsigned, 32));
      IF to_signed(i, 32) >= cast_1(i) THEN 
        x_0 := x_1;
        x_0(1 TO 23) := x_1(0 TO 22);
        x_0(0) := A_signed(to_integer(resize(tmp_2, 32) - 1));

        FOR jC IN 0 TO 27 LOOP
          IF (jC + 1) > to_signed(16#00000018#, 32) THEN 
            tmp_1 := to_signed(16#00000016#, 32);
          ELSE 
            tmp_1 := to_signed(jC - 1, 32);
          END IF;
          IF (jC + 2) > to_signed(16#00000005#, 32) THEN 
            tmp_0 := to_signed(jC - 4, 32);
          ELSE 
            tmp_0 := to_signed(16#00000000#, 32);
          END IF;
          sub_temp := tmp_1 - tmp_0;
          ABZero := resize(x_0(to_integer(tmp_0)) * estimated_secondary_path_signed(to_integer(to_signed(jC, 32) - tmp_0)), 9);

          FOR k IN 0 TO 22 LOOP
            tmp := (tmp_0 + to_signed(k, 32)) + 1;
            IF to_signed(k, 32) <= sub_temp THEN 
              add_temp_6(k) := resize(ABZero, 10) + resize(x_0(to_integer(tmp)) * estimated_secondary_path_signed(to_integer(to_signed(jC, 32) - tmp)), 10);
              ABZero := add_temp_6(k)(8 DOWNTO 0);
            END IF;
          END LOOP;

          c_1(jC) := ABZero;
        END LOOP;

        c_0 := to_signed(16#000#, 11);

        FOR k_4 IN 0 TO 23 LOOP
          cast_6(k_4) := c_1(k_4)(3 DOWNTO 0);
          add_temp_2(k_4) := resize(c_0, 12) + resize(w_0(k_4) * cast_6(k_4), 12);
          c_0 := add_temp_2(k_4)(10 DOWNTO 0);
        END LOOP;

        Est1(to_integer(resize(tmp_2, 32) - 1)) := c_0(2 DOWNTO 0);
        x_1 := x_0;
      END IF;
    END LOOP;

    -- Computing the error signal
    w_tmp <= w_0;

    FOR t_0 IN 0 TO 999 LOOP
      E_tmp(t_0) <= E1(t_0);
      Est_tmp(t_0) <= Est1(t_0);
      Err_tmp(t_0) <= Est1(t_0) - D_signed(t_0);
    END LOOP;

  END PROCESS fxlms_algorithm_fixpt_1_output;


  outputgen3: FOR k1 IN 0 TO 23 GENERATE
    w(k1) <= std_logic_vector(w_tmp(k1));
  END GENERATE;

  outputgen2: FOR k1 IN 0 TO 999 GENERATE
    E(k1) <= std_logic_vector(E_tmp(k1));
  END GENERATE;

  outputgen1: FOR k1 IN 0 TO 999 GENERATE
    Est(k1) <= std_logic_vector(Est_tmp(k1));
  END GENERATE;

  outputgen: FOR k1 IN 0 TO 999 GENERATE
    Err(k1) <= std_logic_vector(Err_tmp(k1));
  END GENERATE;

END rtl;

